# 역할, 책임, 협력

### Recap
- 다형성은 지연 바인딩을 통해 구현된다.
- **상속**은 코드를 재사용할 수 있는 잘 알려진 방법이지만, 캡슐화의 측면에서 **합성**이 더 좋은 방법이다.
- 컴파일 시간 의존성과 실행 시간 의존성이 달라야 한다.

---

- 객체지향 패러다임의 관전에서 핵심은 **`역할(role)`**, **`책임(responsibility)`**, **`협력(collaboration)`** 
> **역할, 책임, 협력이 제자리를 찾지 못한 상태라면 응집도 높은 클래스와 중복 없는 상속 계층을 구현한다고 해도, 어플리케이션이 침몰하는 것을 구원하지 못할 것이다.** 

## 협력(collaboration)

### 영화 예매 시스템 돌아보기

- 어떤 시스템이 원하는 기능을 처리하려면 다양한 객체들이 참여하는 **협력**을 구축
- 객체지향 원칙을 따르는 애플리케이션의 제어의 흐름은 어떤 객체에 의해 통제되지 않고, 객체들 사이에 균형있게 분배된다. 

    (참고 이미지 flow chart)
    
- 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**,
- 객체가 협력에 참여하기 위해 수행하는 로직은 **책임**, 
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행는 **역할**을 구성한다.

---

### 협력
- 객체지향 시스템은 **자율적인 객체**들의 공동체
- 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 **협력**하는 사회적인 존재 
    - **협력**은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법
- **메시지 전송(message sending)** 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단
- 메시지를 수신한 객체는 **메서드**를 실행해 요청에 응답한다. 
- 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.(**자율적인 존재**)
- **자율적인 객채**란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체 -> 가장 기본적인 방법은 내부 구현을 **캡슐화**

```
'자율적인 객체'는 자신에게 할당된 '책임'을 수행하던 중에 
필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 
적절한 객체에게 '메시지를 전송'해서 '협력'을 요청한다.
```

---

### 협력이 설계를 위한 문맥을 결정한다

> **어떤 객체도 섬이 아니다.** 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. 그 **객체가 어떤 협력에 참여**하고 있기 때문이다. 
그리고 객체가 협력에 참여할 수 있는 이유는 **협력에 필요한 적절한 행동을 보유**하고 있기 때문이다. 

- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.
- 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.
- **객체의 행동**을 결정하는 것이 **협력**이라면, **객체의 상태**를 결정하는 것은 **행동**이다.
- 객체 상태 <- 객체 행동 <- 협력
- 협력은 객체를 설계하는데 필요한 일종의 **문맥(context)**이다.

## 책임(responsibility)


## 역할(role)